package IC.lir;

import java.util.HashMap;
import java.util.Map;

import IC.AST.Method;
import IC.lir.lirAST.Label;



/**
 * 
 * This class is responsible for generating all types of labels:
 * 	- DV class pointer labels
 *  - method name labels
 *  - string name labels
 *  - 
 *
 */

public class LabelGenerator {

	
	/**
	 * number of string literals generated so far
	 * index of next string literal
	 */
	private int stringLiteralCounter = 0;
	
	/**
	 * maps each string literal it seen so far to a label object
	 */
	private Map<String, Label> stringLiteralLabels = new HashMap<String, Label>();
	
	
	/**
	 * maps each class we've seen so far to a label object
	 */
	private Map<String, Label> classDispatchTableLabels = new HashMap<String, Label>();
	
	
	/**
	 * maps class name -> method name -> label  [virtual methods only ]
	 */
	private Map<String, Map<String, Label>> methodLabels = new HashMap<String,  Map<String, Label>>();
	
	
	/**
	 * maps class name -> method name -> label  [static methods only ]
	 */
	private Map<String, Map<String, Label>> staticMethodLabels = new HashMap<String,  Map<String, Label>>();
	
	
	
	/**
	 * maps library method names -> labels
	 */
	
	private Map<String, Label> libraryMethodLabels = new HashMap<String, Label>();
	
	/**
	 * labels for runtime check methods
	 * 
	 */
	private Map<String, Label> runtimeChecksLabels = new HashMap<String, Label>();
	
	
	/**
	 * for other kinds of labels (such as, those generated by if, while, conditions..)
	 * this counts the number of unique labels we've created so far
	 */
	
	private int uniqueLabelCounter = 0 ;
	
	
	
	/**
	 * label of the main method, only one exists and can be allocated at object initialization
	 * entry point
	 */
	
	private Label mainMethodLabel = new Label("_ic_main");
	
	
	/**
	 *  label of the exit point of the program
	 */
	
	private Label exitLabel = new Label("_exit");
	
	
	/**
	 * method returns a label by given string literal
	 * if such a string was already added before, its label will returned
	 * otherwise, a new label will be allocated for the string literal
	 * @param stringLiteral
	 * @return label for the string
	 */
	
	public Label getStringLabel(String stringLiteral)
	{
		Integer index;
		if(stringLiteralLabels.containsKey(stringLiteral))
		{
			// seen this string before
			
		}
		else
		{
			// new string literal
			index = stringLiteralCounter;
			stringLiteralLabels.put(stringLiteral, new Label(generateStringLabel(index)));
			
			++stringLiteralCounter;
			
		}
		
		return stringLiteralLabels.get(stringLiteral);
	}
	
	
	
	
	/**
	 * returns the actual label for a string, by its id
	 * @param index - index of the string
	 * @return actual label
	 */
	private String generateStringLabel(int index)
	{
		return String.format("str%d", index);
	}
	
	/**
	 * returns a class DV label for the given class
	 * @param className
	 * @return DV class label
	 */
	
	public Label getClassDVLabel(String className)
	{
		Label label = this.classDispatchTableLabels.get(className);
		if(label == null)
		{
			this.classDispatchTableLabels.put(className, new Label(String.format("_DV_%s", className)));
			label = this.classDispatchTableLabels.get(className);
		}
		
		
		return label;
	}
	
	/**
	 * returns a label for the given VIRTUAL method
	 * @param methodName - name of the method
	 * @param className  - name of the class
	 * @return the label name for the method
	 */
	
	public Label getVirtualMethodLabel(String methodName, String className)
	{
		
		Map<String, Label> methodsToLabels = this.methodLabels.get(className);
		if(methodsToLabels == null)
		{
			// first time we see this class name
			methodsToLabels = new HashMap<String, Label>();
			Label label = new Label( String.format("_%s_%s", className, methodName));
			methodsToLabels.put(methodName, label);
			this.methodLabels.put(className, methodsToLabels);
			
			return label;
		}
		
		Label methodLabel = methodsToLabels.get(methodName);
		if(methodLabel == null)
		{
			// no such label was added yet
			Label label = new Label( String.format("_%s_%s", className, methodName));
			methodsToLabels.put(methodName, label);
			return label;
		}
		
		// else, it exists
		return methodLabel;
		
		
	}
	
	/**
	 * returns a label for the given STATIC method
	 * @param methodName - name of the method
	 * @param className  - name of the class
	 * @return the label name for the method
	 */
	
	public Label getStaticMethodLabel(String methodName, String className)
	{
		// special case
		if(methodName.equals("main"))
		{
			return this.mainMethodLabel;
		}
		
		
		Map<String, Label> methodsToLabels = this.staticMethodLabels.get(className);
		if(methodsToLabels == null)
		{
			// first time we see this class name
			methodsToLabels = new HashMap<String, Label>();
			Label label = new Label( String.format("_static_%s_%s", className, methodName));
			methodsToLabels.put(methodName, label);
			this.staticMethodLabels.put(className, methodsToLabels);
			
			return label;
		}
		
		Label methodLabel = methodsToLabels.get(methodName);
		if(methodLabel == null)
		{
			// no such label was added yet
			Label label = new Label( String.format("_static_%s_%s", className, methodName));
			methodsToLabels.put(methodName, label);
			return label;
		}
		
		// else, it exists
		return methodLabel;
		
		
	}
	
	
	
	
	/**
	 * this method returns a label for the given library method name
	 * if such a label was already created, it will be returned
	 * @param name of library method
	 * @return
	 */
	
	public Label getLibraryMethodLabel(String name)
	{
		
		if(libraryMethodLabels.get(name) == null)
		{
			libraryMethodLabels.put(name, new Label("__" + name));
		}
		
		return libraryMethodLabels.get(name);
		
	}
	
	
	/**
	 * for other kinds of labels (such as, those generated by if, while, conditions..)
	 * use this method to generate a new unique label (unique in the entire program)
	 * @return
	 * 			a new label will be returned with the following format: _label_5
	 */
	
	public Label createLabel()
	{
		return new Label(String.format("_label_%d", uniqueLabelCounter++));
		
	}
	
	
	/**
	 * 
	 * @return exit label for program [singleton]
	 */
	
	public Label getExitLabel()
	{
		
		return this.exitLabel;
	}
	
	/**
	 * 
	 * @return the main method label for the program [singleton]
	 */
	
	public Label mainMethodLabel()
	{
		return this.mainMethodLabel;
		
	}
	
	/**
	 * method returns (and maintains) labels for our custom runtime check methods
	 * @param methodName - name of method
	 * @return label
	 */
	
	
	public Label getRuntimeCheckLabel(String methodName)
	{
		
		if(this.runtimeChecksLabels.get(methodName) == null)
		{
			runtimeChecksLabels.put(methodName, new Label("__" + methodName));
			
		}
		return runtimeChecksLabels.get(methodName);
		
	}
	
	
	
	
}
